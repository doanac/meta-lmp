From 7afea08e64072f21469f617010e0ecde6b64ac7b Mon Sep 17 00:00:00 2001
From: Andy Doan <andy@foundries.io>
Date: Thu, 26 Sep 2019 13:33:38 -0500
Subject: [PATCH 08/18] aktualizr-lite: Introduce a "LiteClient"

The functions in aktualizr lite usually need references to at least
the SotaUptaneClient, Config, and Storage objects. This change makes
it easier to pass these things around.

It also makes it a little easier to expose other things in the future
like the report_queue.

Signed-off-by: Andy Doan <andy@foundries.io>
---
 src/aktualizr_lite/helpers.cc      |  9 ++----
 src/aktualizr_lite/helpers.h       |  8 +++++-
 src/aktualizr_lite/helpers_test.cc | 11 ++++---
 src/aktualizr_lite/main.cc         | 46 ++++++++++++++----------------
 4 files changed, 39 insertions(+), 35 deletions(-)

diff --git a/src/aktualizr_lite/helpers.cc b/src/aktualizr_lite/helpers.cc
index a2d7a9cc..1c2e54d9 100644
--- a/src/aktualizr_lite/helpers.cc
+++ b/src/aktualizr_lite/helpers.cc
@@ -25,11 +25,9 @@ static void finalizeIfNeeded(INvStorage &storage, PackageConfig &config) {
   }
 }
 
-std::shared_ptr<SotaUptaneClient> liteClient(Config &config, std::shared_ptr<INvStorage> storage) {
+LiteClient::LiteClient(Config &config_in) : config(std::move(config_in)) {
   std::string pkey;
-  if (storage == nullptr) {
-    storage = INvStorage::newStorage(config.storage);
-  }
+  storage = INvStorage::newStorage(config.storage);
   storage->importData(config.import);
 
   EcuSerials ecu_serials;
@@ -55,7 +53,6 @@ std::shared_ptr<SotaUptaneClient> liteClient(Config &config, std::shared_ptr<INv
   KeyManager keys(storage, config.keymanagerConfig());
   keys.copyCertsToCurl(*http_client);
 
-  auto client = std::make_shared<SotaUptaneClient>(config, storage, http_client, bootloader, report_queue);
+  primary = std::make_shared<SotaUptaneClient>(config, storage, http_client, bootloader, report_queue);
   finalizeIfNeeded(*storage, config.pacman);
-  return client;
 }
diff --git a/src/aktualizr_lite/helpers.h b/src/aktualizr_lite/helpers.h
index 6b24158f..41ca0393 100644
--- a/src/aktualizr_lite/helpers.h
+++ b/src/aktualizr_lite/helpers.h
@@ -14,6 +14,12 @@ struct Version {
   bool operator<(const Version& other) { return strverscmp(raw_ver.c_str(), other.raw_ver.c_str()) < 0; }
 };
 
-std::shared_ptr<SotaUptaneClient> liteClient(Config& config, std::shared_ptr<INvStorage> storage);
+struct LiteClient {
+  LiteClient(Config& config_in);
+
+  Config config;
+  std::shared_ptr<INvStorage> storage;
+  std::shared_ptr<SotaUptaneClient> primary;
+};
 
 #endif  // AKTUALIZR_LITE_HELPERS
diff --git a/src/aktualizr_lite/helpers_test.cc b/src/aktualizr_lite/helpers_test.cc
index c3d30829..245fd9b4 100644
--- a/src/aktualizr_lite/helpers_test.cc
+++ b/src/aktualizr_lite/helpers_test.cc
@@ -39,13 +39,16 @@ TEST(helpers, lite_client_finalize) {
 
   setenv("OSTREE_HASH", "deadbeef", 1);
   storage->savePrimaryInstalledVersion(target, InstalledVersionUpdateMode::kPending);
-  auto client = liteClient(config, storage);
-  ASSERT_TRUE(target.MatchHash(client->getCurrent().hashes()[0]));
+  ASSERT_TRUE(target.MatchHash(LiteClient(config).primary->getCurrent().hashes()[0]));
+
+  config = Config();  // Create a new config since LiteClient std::move's it
+  config.storage.path = cfg_dir.Path();
+  config.pacman.type = PackageManager::kOstree;
+  config.pacman.sysroot = test_sysroot;
 
   setenv("OSTREE_HASH", "abcd", 1);
   storage->savePrimaryInstalledVersion(target, InstalledVersionUpdateMode::kPending);
-  client = liteClient(config, storage);
-  ASSERT_FALSE(target.MatchHash(client->getCurrent().hashes()[0]));
+  ASSERT_FALSE(target.MatchHash(LiteClient(config).primary->getCurrent().hashes()[0]));
 }
 
 #ifndef __NO_MAIN__
diff --git a/src/aktualizr_lite/main.cc b/src/aktualizr_lite/main.cc
index d5ca3c05..57d052e2 100644
--- a/src/aktualizr_lite/main.cc
+++ b/src/aktualizr_lite/main.cc
@@ -34,9 +34,9 @@ static void log_info_target(const std::string &prefix, const Config &config, con
   }
 }
 
-static int status_main(Config &config, const bpo::variables_map &unused) {
+static int status_main(LiteClient &client, const bpo::variables_map &unused) {
   (void)unused;
-  auto target = liteClient(config, nullptr)->getCurrent();
+  auto target = client.primary->getCurrent();
 
   if (target.MatchTarget(Uptane::Target::Unknown())) {
     LOG_INFO << "No active deployment found";
@@ -45,30 +45,29 @@ static int status_main(Config &config, const bpo::variables_map &unused) {
     if (target.custom_version().length() > 0) {
       name = target.custom_version();
     }
-    log_info_target("Active image is: ", config, target);
+    log_info_target("Active image is: ", client.config, target);
   }
   return 0;
 }
 
-static int list_main(Config &config, const bpo::variables_map &unused) {
+static int list_main(LiteClient &client, const bpo::variables_map &unused) {
   (void)unused;
-  auto client = liteClient(config, nullptr);
-  Uptane::HardwareIdentifier hwid(config.provision.primary_ecu_hardware_id);
+  Uptane::HardwareIdentifier hwid(client.config.provision.primary_ecu_hardware_id);
 
   LOG_INFO << "Refreshing target metadata";
-  if (!client->updateImagesMeta()) {
+  if (!client.primary->updateImagesMeta()) {
     LOG_WARNING << "Unable to update latest metadata, using local copy";
-    if (!client->checkImagesMetaOffline()) {
+    if (!client.primary->checkImagesMetaOffline()) {
       LOG_ERROR << "Unable to use local copy of TUF data";
       return 1;
     }
   }
 
   LOG_INFO << "Updates available to " << hwid << ":";
-  for (auto &t : client->allTargets()) {
+  for (auto &t : client.primary->allTargets()) {
     for (auto const &it : t.hardwareIds()) {
       if (it == hwid) {
-        log_info_target("", config, t);
+        log_info_target("", client.config, t);
         break;
       }
     }
@@ -108,22 +107,22 @@ static std::unique_ptr<Uptane::Target> find_target(const std::shared_ptr<SotaUpt
   throw std::runtime_error("Unable to find update");
 }
 
-static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Target &target) {
-  if (!client.downloadImage(target).first) {
+static int do_update(LiteClient &client, Uptane::Target &target) {
+  if (!client.primary->downloadImage(target).first) {
     return 1;
   }
 
-  if (client.VerifyTarget(target) != TargetStatus::kGood) {
+  if (client.primary->VerifyTarget(target) != TargetStatus::kGood) {
     LOG_ERROR << "Downloaded target is invalid";
     return 1;
   }
 
-  auto iresult = client.PackageInstall(target);
+  auto iresult = client.primary->PackageInstall(target);
   if (iresult.result_code.num_code == data::ResultCode::Numeric::kNeedCompletion) {
     LOG_INFO << "Update complete. Please reboot the device to activate";
-    storage.saveInstalledVersion("", target, InstalledVersionUpdateMode::kPending);
+    client.storage->savePrimaryInstalledVersion(target, InstalledVersionUpdateMode::kPending);
   } else if (iresult.result_code.num_code == data::ResultCode::Numeric::kOk) {
-    storage.saveInstalledVersion("", target, InstalledVersionUpdateMode::kCurrent);
+    client.storage->savePrimaryInstalledVersion(target, InstalledVersionUpdateMode::kCurrent);
   } else {
     LOG_ERROR << "Unable to install update: " << iresult.description;
     return 1;
@@ -132,24 +131,22 @@ static int do_update(SotaUptaneClient &client, INvStorage &storage, Uptane::Targ
   return 0;
 }
 
-static int update_main(Config &config, const bpo::variables_map &variables_map) {
-  auto storage = INvStorage::newStorage(config.storage);
-  auto client = liteClient(config, storage);
-  Uptane::HardwareIdentifier hwid(config.provision.primary_ecu_hardware_id);
+static int update_main(LiteClient &client, const bpo::variables_map &variables_map) {
+  Uptane::HardwareIdentifier hwid(client.config.provision.primary_ecu_hardware_id);
 
   std::string version("latest");
   if (variables_map.count("update-name") > 0) {
     version = variables_map["update-name"].as<std::string>();
   }
   LOG_INFO << "Finding " << version << " to update to...";
-  auto target = find_target(client, hwid, version);
+  auto target = find_target(client.primary, hwid, version);
   LOG_INFO << "Updating to: " << *target;
-  return do_update(*client, *storage, *target);
+  return do_update(client, *target);
 }
 
 struct SubCommand {
   const char *name;
-  int (*main)(Config &, const bpo::variables_map &);
+  int (*main)(LiteClient &, const bpo::variables_map &);
 };
 static SubCommand commands[] = {
     {"status", status_main},
@@ -250,7 +247,8 @@ int main(int argc, char *argv[]) {
     std::string cmd = commandline_map["command"].as<std::string>();
     for (size_t i = 0; i < sizeof(commands) / sizeof(SubCommand); i++) {
       if (cmd == commands[i].name) {
-        return commands[i].main(config, commandline_map);
+        LiteClient client(config);
+        return commands[i].main(client, commandline_map);
       }
     }
     throw bpo::invalid_option_value(cmd);
-- 
2.23.0


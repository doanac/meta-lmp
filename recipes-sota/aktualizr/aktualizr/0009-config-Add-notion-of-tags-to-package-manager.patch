From 463a645691653c84e3806bdfc890bea0323e6a61 Mon Sep 17 00:00:00 2001
From: Andy Doan <andy@foundries.io>
Date: Fri, 28 Jun 2019 09:36:22 -0500
Subject: [PATCH 09/18] config: Add notion of "tags" to package manager

The idea here is that the aktualizr lite client can look at tags
in each target to decide if its applicable to for the device. This
would allow us to use one TUF repo to support things like premerge
and release builds.

Signed-off-by: Andy Doan <andy@foundries.io>
---
 src/aktualizr_lite/helpers.cc                 | 14 +++++++++
 src/aktualizr_lite/helpers.h                  |  3 ++
 src/aktualizr_lite/helpers_test.cc            | 31 +++++++++++++++++++
 src/aktualizr_lite/main.cc                    | 15 +++++++--
 src/aktualizr_lite/test_lite.sh               | 15 ++++++---
 .../package_manager/packagemanagerconfig.cc   |  7 ++++-
 .../package_manager/packagemanagerconfig.h    |  1 +
 7 files changed, 78 insertions(+), 8 deletions(-)

diff --git a/src/aktualizr_lite/helpers.cc b/src/aktualizr_lite/helpers.cc
index 1c2e54d9..6a81530a 100644
--- a/src/aktualizr_lite/helpers.cc
+++ b/src/aktualizr_lite/helpers.cc
@@ -56,3 +56,17 @@ LiteClient::LiteClient(Config &config_in) : config(std::move(config_in)) {
   primary = std::make_shared<SotaUptaneClient>(config, storage, http_client, bootloader, report_queue);
   finalizeIfNeeded(*storage, config.pacman);
 }
+
+bool target_has_tags(const Uptane::Target &t, const std::vector<std::string> &config_tags) {
+  if (!config_tags.empty()) {
+    auto tags = t.custom_data()["tags"];
+    for (Json::ValueIterator i = tags.begin(); i != tags.end(); ++i) {
+      auto tag = (*i).asString();
+      if (std::find(config_tags.begin(), config_tags.end(), tag) != config_tags.end()) {
+        return true;
+      }
+    }
+    return false;
+  }
+  return true;
+}
diff --git a/src/aktualizr_lite/helpers.h b/src/aktualizr_lite/helpers.h
index 41ca0393..6214c5f6 100644
--- a/src/aktualizr_lite/helpers.h
+++ b/src/aktualizr_lite/helpers.h
@@ -6,6 +6,7 @@
 #include <string.h>
 
 #include "primary/sotauptaneclient.h"
+#include "uptane/tuf.h"
 
 struct Version {
   std::string raw_ver;
@@ -22,4 +23,6 @@ struct LiteClient {
   std::shared_ptr<SotaUptaneClient> primary;
 };
 
+bool target_has_tags(const Uptane::Target& t, const std::vector<std::string>& config_tags);
+
 #endif  // AKTUALIZR_LITE_HELPERS
diff --git a/src/aktualizr_lite/helpers_test.cc b/src/aktualizr_lite/helpers_test.cc
index 245fd9b4..ca13ef13 100644
--- a/src/aktualizr_lite/helpers_test.cc
+++ b/src/aktualizr_lite/helpers_test.cc
@@ -51,6 +51,37 @@ TEST(helpers, lite_client_finalize) {
   ASSERT_FALSE(target.MatchHash(LiteClient(config).primary->getCurrent().hashes()[0]));
 }
 
+TEST(helpers, target_has_tags) {
+  auto t = Uptane::Target::Unknown();
+
+  // No tags defined in target:
+  std::vector<std::string> config_tags;
+  ASSERT_TRUE(target_has_tags(t, config_tags));
+  config_tags.push_back("foo");
+  ASSERT_FALSE(target_has_tags(t, config_tags));
+
+  // Set target tags to: premerge, qa
+  auto custom = t.custom_data();
+  custom["tags"].append("premerge");
+  custom["tags"].append("qa");
+  t.updateCustom(custom);
+
+  config_tags.clear();
+  ASSERT_TRUE(target_has_tags(t, config_tags));
+
+  config_tags.push_back("qa");
+  config_tags.push_back("blah");
+  ASSERT_TRUE(target_has_tags(t, config_tags));
+
+  config_tags.clear();
+  config_tags.push_back("premerge");
+  ASSERT_TRUE(target_has_tags(t, config_tags));
+
+  config_tags.clear();
+  config_tags.push_back("foo");
+  ASSERT_FALSE(target_has_tags(t, config_tags));
+}
+
 #ifndef __NO_MAIN__
 int main(int argc, char **argv) {
   ::testing::InitGoogleTest(&argc, argv);
diff --git a/src/aktualizr_lite/main.cc b/src/aktualizr_lite/main.cc
index 57d052e2..ca5c87a5 100644
--- a/src/aktualizr_lite/main.cc
+++ b/src/aktualizr_lite/main.cc
@@ -65,6 +65,9 @@ static int list_main(LiteClient &client, const bpo::variables_map &unused) {
 
   LOG_INFO << "Updates available to " << hwid << ":";
   for (auto &t : client.primary->allTargets()) {
+    if (!target_has_tags(t, client.config.pacman.tags)) {
+      continue;
+    }
     for (auto const &it : t.hardwareIds()) {
       if (it == hwid) {
         log_info_target("", client.config, t);
@@ -76,7 +79,8 @@ static int list_main(LiteClient &client, const bpo::variables_map &unused) {
 }
 
 static std::unique_ptr<Uptane::Target> find_target(const std::shared_ptr<SotaUptaneClient> &client,
-                                                   Uptane::HardwareIdentifier &hwid, const std::string &version) {
+                                                   Uptane::HardwareIdentifier &hwid,
+                                                   const std::vector<std::string> &tags, const std::string &version) {
   std::unique_ptr<Uptane::Target> rv;
   if (!client->updateImagesMeta()) {
     LOG_WARNING << "Unable to update latest metadata, using local copy";
@@ -89,6 +93,9 @@ static std::unique_ptr<Uptane::Target> find_target(const std::shared_ptr<SotaUpt
   bool find_latest = (version == "latest");
   std::unique_ptr<Uptane::Target> latest = nullptr;
   for (auto &t : client->allTargets()) {
+    if (!target_has_tags(t, tags)) {
+      continue;
+    }
     for (auto const &it : t.hardwareIds()) {
       if (it == hwid) {
         if (find_latest) {
@@ -139,7 +146,11 @@ static int update_main(LiteClient &client, const bpo::variables_map &variables_m
     version = variables_map["update-name"].as<std::string>();
   }
   LOG_INFO << "Finding " << version << " to update to...";
-  auto target = find_target(client.primary, hwid, version);
+  auto target = find_target(client.primary, hwid, client.config.pacman.tags, version);
+  if (target == nullptr) {
+    LOG_INFO << "Already up-to-date";
+    return 0;
+  }
   LOG_INFO << "Updating to: " << *target;
   return do_update(client, *target);
 }
diff --git a/src/aktualizr_lite/test_lite.sh b/src/aktualizr_lite/test_lite.sh
index ccdeafa1..d2b17423 100755
--- a/src/aktualizr_lite/test_lite.sh
+++ b/src/aktualizr_lite/test_lite.sh
@@ -70,16 +70,16 @@ repo_server = "http://localhost:$port/repo/repo"
 [provision]
 primary_ecu_hardware_id = "hwid-for-test"
 
-[pacman]
-type = "ostree"
-sysroot = "$OSTREE_SYSROOT"
-os = "dummy-os"
-
 [storage]
 type = "sqlite"
 path = "$sota_dir"
 sqldb_path = "sql.db"
 uptane_metadata_path = "$sota_dir/metadata"
+
+[pacman]
+type = "ostree"
+sysroot = "$OSTREE_SYSROOT"
+os = "dummy-os"
 EOF
 
 ## Check that we can do the info command
@@ -114,3 +114,8 @@ if [[ ! "$out" =~ "Active image is: zlast	sha256:$sha" ]] ; then
     echo $out
     exit 1
 fi
+
+## Make sure we obey tags
+echo 'tags = "promoted"' >> $sota_dir/sota.toml
+cd /tmp/
+OSTREE_HASH=$sha LD_PRELOAD=$mock_ostree $valgrind $aklite --loglevel 1 -c $sota_dir/sota.toml update | grep "Already up-to-date"
diff --git a/src/libaktualizr/package_manager/packagemanagerconfig.cc b/src/libaktualizr/package_manager/packagemanagerconfig.cc
index 53677bd8..c36ef082 100644
--- a/src/libaktualizr/package_manager/packagemanagerconfig.cc
+++ b/src/libaktualizr/package_manager/packagemanagerconfig.cc
@@ -33,8 +33,12 @@ void PackageConfig::updateFromPropertyTree(const boost::property_tree::ptree& pt
   CopyFromConfig(ostree_server, "ostree_server", pt);
   CopyFromConfig(packages_file, "packages_file", pt);
   CopyFromConfig(fake_need_reboot, "fake_need_reboot", pt);
-#ifdef BUILD_DOCKERAPP
   std::string val;
+  CopyFromConfig(val, "tags", pt);
+  if (val.length() > 0) {
+    boost::split(tags, val, boost::is_any_of(", "), boost::token_compress_on);
+  }
+#ifdef BUILD_DOCKERAPP
   CopyFromConfig(val, "docker_apps", pt);
   if (val.length() > 0) {
     // token_compress_on allows lists like: "foo,bar", "foo, bar", or "foo bar"
@@ -54,6 +58,7 @@ void PackageConfig::writeToStream(std::ostream& out_stream) const {
   writeOption(out_stream, ostree_server, "ostree_server");
   writeOption(out_stream, packages_file, "packages_file");
   writeOption(out_stream, fake_need_reboot, "fake_need_reboot");
+  writeOption(out_stream, boost::algorithm::join(tags, ","), "tags");
 #ifdef BUILD_DOCKERAPP
   writeOption(out_stream, boost::algorithm::join(docker_apps, ","), "docker_apps");
   writeOption(out_stream, docker_apps_root, "docker_apps_root");
diff --git a/src/libaktualizr/package_manager/packagemanagerconfig.h b/src/libaktualizr/package_manager/packagemanagerconfig.h
index d19bdd87..f0f3c9a1 100644
--- a/src/libaktualizr/package_manager/packagemanagerconfig.h
+++ b/src/libaktualizr/package_manager/packagemanagerconfig.h
@@ -16,6 +16,7 @@ struct PackageConfig {
   boost::filesystem::path sysroot;
   std::string ostree_server;
   boost::filesystem::path packages_file{"/usr/package.manifest"};
+  std::vector<std::string> tags;
 
 #ifdef BUILD_DOCKERAPP
   std::vector<std::string> docker_apps;
-- 
2.23.0

